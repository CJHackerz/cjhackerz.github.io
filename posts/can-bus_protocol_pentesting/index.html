<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>CAN-bus protocol pentesting and forensics :: Chirag Jariwala — Cyber security analyst and IoT security researcher</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Introduction CAN (Controller Area Network) is a vehicle bus protocol standard which allows microcontrollers and ECU (electronic control units) to communicate which each other without a host computer. It is a message-based protocol, designed originally for multiplex electrical wiring within automobiles to save on copper, but can also be used in many other contexts. But why CAN you may ask, because it&amp;rsquo;s low-cost error less since via single CAN interface ECU can communicate with each through the centralized system with less wiring involved and data is transferred over digital signal instead of analog so it reduces chances of error occurrence." />
<meta name="keywords" content="cjhackerz" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://cjhackerz.net/posts/can-bus_protocol_pentesting/" />


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-142682190-1', 'auto');
	
	ga('send', 'pageview');
}
</script>



<link rel="stylesheet" href="https://cjhackerz.net/assets/style.css">

  <link rel="stylesheet" href="https://cjhackerz.net/assets/red.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://cjhackerz.net/img/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="https://cjhackerz.net/img/favicon/red.png">



<meta name="twitter:card" content="summary" />

<meta name="twitter:creator" content="CJHackerz" />


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="CAN-bus protocol pentesting and forensics :: Chirag Jariwala">
<meta property="og:description" content="CAN (Controller Area Network) is a vehicle bus protocol standard which allows microcontrollers and ECU (electronic control units) to communicate which each other without a host computer. It is a message-based protocol, designed originally for multiplex electrical wiring within automobiles to save on copper." />
<meta property="og:url" content="https://cjhackerz.net/posts/can-bus_protocol_pentesting/" />
<meta property="og:site_name" content="CAN-bus protocol pentesting and forensics" />

  <meta property="og:image" content="https://cjhackerz.net/img/canbus_article_cover.png">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2019-08-17 00:00:00 &#43;0000 UTC" />












</head>
<body class="">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    CJHackerz.Net
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/contact">Contact</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/contact">Contact</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://cjhackerz.net/posts/can-bus_protocol_pentesting/">CAN-bus protocol pentesting and forensics</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2019-08-17 
      </span>
    
    
    <span class="post-author">::
      CJHackerz
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://cjhackerz.net/tags/iot/">IoT</a>&nbsp;
    
    #<a href="https://cjhackerz.net/tags/hardware/">Hardware</a>&nbsp;
    
    #<a href="https://cjhackerz.net/tags/automotive/">Automotive</a>&nbsp;
    
  </span>
  

  
    <img src="https://cjhackerz.net/img/canbus_article_cover.png" class="post-cover" alt="CAN-bus protocol pentesting and forensics" />
  

  

  <div class="post-content"><div>
        <h2 id="introduction">Introduction<a href="#introduction" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>CAN (Controller Area Network) is a vehicle bus protocol standard which allows microcontrollers and ECU (electronic control units) to communicate which each other without a host computer. It is a message-based protocol, designed originally for multiplex electrical wiring within automobiles to save on copper, but can also be used in many other contexts. But why CAN you may ask, because it&rsquo;s low-cost error less since via single CAN interface ECU can communicate with each through the centralized system with less wiring involved and data is transferred over digital signal instead of analog so it reduces chances of error occurrence. Also, it&rsquo;s a tolerant system against electromagnetic noise which makes it best fit for vehicle electronics system.</p>
<p>There is another protocol which works on top of CAN called OBD (On-board diagnostics). OBD adds up the transport layer for CAN.</p>

  <figure class="center" >
    <img src="/img/canbusVobdVsosi.svg"  alt="CAN vs. OBD vs. OSI layers"   style="border-radius: 10px;"  />
    
      <figcaption class="center"  style="color: white;" >CAN vs. OBD vs. OSI layers</figcaption>
    
  </figure>


<p>For physical layer CAN have two major standards to transmit data over a physical medium (wires)</p>
<ul>
<li>High Speed CAN Signaling. ISO 11898-2 (frequent error occurrence)</li>
<li>Low-Speed Fault Tolerant CAN Network. ISO 11898-3 (less error occurrence)</li>
</ul>

  <figure class="center" >
    <img src="/img/CAN_Node.png"  alt="CAN node"   style="border-radius: 10px;"  />
    
      <figcaption class="center"  style="color: white;" >CAN node layout</figcaption>
    
  </figure>


<p>I won&rsquo;t provide more details of the standards above, because as IoT security researchers Data Link and Network layers are what we should be interested in. Let&rsquo;s have look at standard CAN message frame format which gets transmitted over network.</p>

  <figure class="center" >
    <img src="/img/can_message_frame.png"  alt="CAN message frame"   style="border-radius: 10px;"  />
    
  </figure>


<ul>
<li><strong>SOF (Start of Frame):</strong> Tells other ECUs that message is incoming</li>
<li><strong>CAN-ID:</strong> Contains priority bits for message along with functional address of ECU (in terms of networking CAN-ID is like mac address, but not same thing)</li>
<li><strong>RTR:</strong> Remote transmission requests allows ECU to request messages from other active ECUs on network</li>
<li><strong>CONTROL:</strong> Informs length of the data in bytes</li>
<li><strong>DATA:</strong> Contains data values to be transmitted over protocol</li>
<li><strong>CRC:</strong> Cyclic Redudancy Values for error correction and data integrity</li>
<li><strong>ACK:</strong>  It indicates status of CRC process</li>
<li><strong>EOF</strong>: End of frame marks the end of CAN message frame</li>
</ul>
<p>Now for network packet forseics we only need to worry about <strong>CAN-ID</strong>, <strong>CONTROL</strong> and <strong>DATA</strong></p>

  <figure class="center" >
    <img src="/img/canbus-traffic-wireshark.png"  alt="CAN traffic wireshark"   style="border-radius: 10px;"  />
    
      <figcaption class="center"  style="color: white;" >CAN-bus traffic in wireshark</figcaption>
    
  </figure>


<p>As we can see in wireshark CAN-bus is event driven, when the data is generated by ECU via certain action (such as changing gears, indicators on/off, door lock/unlock etc.) it&rsquo;s gets instantly broadcasted on network without any message sorting. So if we are looking for CAN-ID of specific ECU it becomes very hard to look through noise of data generated by other active ECUs in system. Thankfully linux got open source software suite called <a href="https://github.com/linux-can/can-utils.git">can-utils</a> which allows us to create network interface for CAN traffic processing and sniffing. It has utility called candump which can display, filter and log CAN data to files.</p>
<h2 id="setting-up-virtual-can-network-for-experimentation-and-fun">Setting up virtual CAN network for experimentation and fun<a href="#setting-up-virtual-can-network-for-experimentation-and-fun" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>So most of us are not brave enough to go out hook some hardware and mess around with actual vehicle but still want to know how CAN traffic acts in real time. Solution is <a href="https://github.com/zombieCraig/ICSim.git">ICSim</a> (Instrument Cluster Simulator for SocketCAN) is simulator of vehicle Dashboard data over virtual CAN network.</p>
<h3 id="steps-to-compile-icsim">Steps to compile ICSim<a href="#steps-to-compile-icsim" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git clone https://github.com/zombieCraig/ICSim.git
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">apt-get install libsdl2-dev libsdl2-image-dev can-utils
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cd ICSim <span style="color:#f92672">&amp;&amp;</span> make <span style="color:#f92672">&amp;&amp;</span> ./setup_vcan.sh
</code></pre></div><p>To start ICSim with default hardcoded CAN-IDs</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">./icsim vcan0
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> ./controls vcan0
</code></pre></div><p>Now shorting changing data according to CAN-ID</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cansniffer vcan0 <span style="color:#75715e">#Any CAN interface of your choice</span>
</code></pre></div><p>Select control window and press Up arrow key to increase speed, you will notice CAN-ID in cansniffer output changing value alot so that CAN-ID is for your vechicle speed data transmitted by engine ECU. You can also capture that traffic in wireshark and save it for further analysis. According to source code file icsim.c default arbitration/CAN-ID for speed data is 0x244.</p>
<p>Scapy recently added support for CAN protocol layer, so now you can all kind of data analysis in python. The basic script below saves all hex values from CAN-ID in array and finds of minimum and maximum speed. The more cool things can be done with matplotlib to create graph for speed data to know how many times vehicle got slow down due to road traffic.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> scapy.all <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">import</span> struct

load_layer(<span style="color:#e6db74">&#34;can&#34;</span>) <span style="color:#75715e">#Allows us to work with CAN-bus network layer please note that it only works with latest veersion of ScaPy library</span>

can_packets <span style="color:#f92672">=</span> rdpcap(<span style="color:#e6db74">&#39;canbus-traffic-capture.pcap&#39;</span>)

CAN_ID <span style="color:#f92672">=</span> <span style="color:#75715e">#Your desired CAN-ID for vehicle speed data in hex format</span>
raw_data <span style="color:#f92672">=</span> []

<span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> can_packets:
        <span style="color:#66d9ef">if</span> x[<span style="color:#e6db74">&#34;CAN&#34;</span>]<span style="color:#f92672">.</span>identifier <span style="color:#f92672">==</span> int(CAN_ID, <span style="color:#ae81ff">16</span>):
            data <span style="color:#f92672">=</span> x[<span style="color:#e6db74">&#34;CAN&#34;</span>]<span style="color:#f92672">.</span>data<span style="color:#f92672">.</span>hex()
            raw_data<span style="color:#f92672">.</span>append(data[<span style="color:#ae81ff">10</span>:]) <span style="color:#75715e">#From traffic analysis we know that speed data only 4-bit long out of 14-bit hex string</span>

raw_data <span style="color:#f92672">=</span> list(set(raw_data))

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Raw RPM data in hex: &#34;</span> <span style="color:#f92672">+</span> str(raw_data))

delta_rpm <span style="color:#f92672">=</span> []

<span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> raw_data:
    delta_rpm<span style="color:#f92672">.</span>append(int(y, <span style="color:#ae81ff">16</span>))


<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Maximum RPM is: &#34;</span> <span style="color:#f92672">+</span> str(max(delta_rpm)))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Minimum RPM is: &#34;</span> <span style="color:#f92672">+</span> str(min(delta_rpm)))
</code></pre></div><p>There are more features in ICSim which allows you to increase difficulty with -r (randomized CAN-IDs) and -l options for learning. Since ScapPy supports CAN you can also write your own ICSim kind of utility in python as well. Check out ScaPy docs for CAN <a href="https://scapy.readthedocs.io/en/latest/layers/automotive.html">here</a>.</p>
<p>For pentesting with external hardware such as <a href="https://www.raspberrypi.org/forums/viewtopic.php?f=44&amp;t=141052">RaspberryPi</a> and Arduino you can order shield with <a href="https://www.sparkfun.com/products/13262">MCP2515 controller</a></p>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://cjhackerz.net/posts/arm-emulated-environment-iotsec-qemu/">
                <span class="button__icon">←</span>
                <span class="button__text">ARM and MIPS emulated lab setup for IoT security in Qemu</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="https://cjhackerz.net/posts/reading-firmware-from-eeprom-easyway/">
                <span class="button__text">Reading data from EEPROM without desoldering</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>© 2020, All rights reserved to Chirag Jariwala</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://cjhackerz.net/assets/main.js"></script>
<script src="https://cjhackerz.net/assets/prism.js"></script>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-142682190-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>

  
</div>

</body>
</html>
